File Path: C:\Users\b.martynowicz\AndroidStudioProjects\DogShare\app\src\main\java\com\dogshare\ui\screens\SwipingScreen.kt
File Name: SwipingScreen.kt
File Type: .kt
Contents:
package com.dogshare.ui.screens

import android.Manifest
import android.content.pm.PackageManager
import android.util.Log
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.*
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.unit.dp
import androidx.core.app.ActivityCompat
import androidx.lifecycle.viewmodel.compose.viewModel
import coil.compose.rememberAsyncImagePainter
import com.dogshare.R
import com.dogshare.models.DogProfile
import com.dogshare.ui.components.Direction
import com.dogshare.ui.components.SwipeableCard
import com.dogshare.ui.components.ToastUtils
import com.dogshare.ui.components.captureLocation
import com.dogshare.ui.components.rememberSwipeableCardState
import com.dogshare.ui.components.storeLocationInFirestore
import com.google.android.gms.location.LocationServices
import com.google.firebase.firestore.FirebaseFirestore
import kotlinx.coroutines.launch

@Composable
fun SwipingScreen(
    userId: String,
    viewModel: SwipingScreenViewModel = viewModel(),
    modifier: Modifier = Modifier
) {
    val context = LocalContext.current
    val fusedLocationClient = remember { LocationServices.getFusedLocationProviderClient(context) }
    val firestore = FirebaseFirestore.getInstance()
    val coroutineScope = rememberCoroutineScope()

    var location by remember { mutableStateOf<Pair<Double, Double>?>(null) }

    // Location permission launcher
    val locationPermissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestPermission(),
        onResult = { granted ->
            if (granted) {
                captureLocation(context, fusedLocationClient) { lat, lon ->
                    location = Pair(lat, lon)
                    storeLocationInFirestore(userId, lat, lon, firestore)
                }
            } else {
                ToastUtils.showToast(context, "Location permission denied.")
            }
        }
    )

    // Request location permission if not already granted
    LaunchedEffect(Unit) {
        if (ActivityCompat.checkSelfPermission(
                context,
                Manifest.permission.ACCESS_FINE_LOCATION
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            locationPermissionLauncher.launch(Manifest.permission.ACCESS_FINE_LOCATION)
        } else {
            captureLocation(context, fusedLocationClient) { lat, lon ->
                location = Pair(lat, lon)
                storeLocationInFirestore(userId, lat, lon, firestore)
            }
        }
    }

    LaunchedEffect(viewModel.currentPhotoIndex) {
        Log.i("SwipingScreen", "Current photo index: ${viewModel.currentPhotoIndex}")
    }

    // Fetch dog photos
    LaunchedEffect(Unit) {
        viewModel.fetchDogProfiles("nNC9XgA77_sgn-co85RYbEaawFa-zopkHRokr7HkSN0")
    }


    if (viewModel.dogProfiles.isEmpty() || viewModel.currentPhotoIndex >= viewModel.dogProfiles.size) {
        // Show loading indicator if there are no photos or still loading
        Box(
            modifier = modifier.fillMaxSize(),
            contentAlignment = Alignment.Center
        ) {
            CircularProgressIndicator()
        }
    } else {
        Box(
            modifier = modifier
                .fillMaxSize()
                .padding(16.dp),
            contentAlignment = Alignment.Center
        ) {
            // Full-screen swipeable card image
            val state = rememberSwipeableCardState()

            SwipeableCard(
                userId = userId,
                DogProfile = viewModel.dogProfiles.map { it.imageUrl },  // List of dog photo URLs
                currentPhotoIndex = viewModel.currentPhotoIndex,
                state = state,
                modifier = Modifier.fillMaxSize(),
                onSwipeComplete = { direction ->
                    coroutineScope.launch {
                        when (direction) {
                            Direction.LEFT -> println("Swiped left: Dislike")
                            Direction.RIGHT -> println("Swiped right: Like")
                            Direction.UP -> println("Swiped up: Skip")
                            Direction.DOWN -> println("Swiped down: Super Like")
                        }
                        viewModel.updatePhotoIndex()
                        Log.i("SwipingScreen", "Current photo index: ${viewModel.currentPhotoIndex}")
                    }
                }
            ) {
                Image(
                    painter = rememberAsyncImagePainter(
                        model = viewModel.dogProfiles[viewModel.currentPhotoIndex].imageUrl
                    ),
                    contentDescription = "Dog Image",
                    modifier = Modifier.fillMaxSize(),
                    contentScale = ContentScale.Crop
                )
            }

            // Overlay Logo and Title on top of the image
            Column(
                modifier = Modifier
                    .align(Alignment.TopCenter)  // Align the logo and title at the top of the image
                    .padding(top = 16.dp),  // Padding for the logo and title
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                // Dogshare logo
                Image(
                    painter = painterResource(id = R.drawable.ic_launcher_round),
                    contentDescription = "Dogshare Logo",
                    modifier = Modifier.size(64.dp)  // Adjust logo size as needed
                )
                // Dogshare title
                Text(
                    text = "Dogshare",
                    style = MaterialTheme.typography.headlineLarge,
                    color = Color.White,  // White color to make the title visible over the image
                    modifier = Modifier.padding(top = 8.dp)
                )
            }
        }
    }
}



File Path: C:\Users\b.martynowicz\AndroidStudioProjects\DogShare\app\src\main\java\com\dogshare\ui\components\SwipeableCard.kt
File Name: SwipeableCard.kt
File Type: .kt
Contents:
package com.dogshare.ui.components

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.animation.core.Animatable
import androidx.compose.animation.core.tween
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.layout.Box
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.layout.layout
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.platform.LocalContext
import androidx.core.app.ActivityCompat
import com.dogshare.models.DogProfile
import com.google.android.gms.location.FusedLocationProviderClient
import com.google.android.gms.location.LocationServices
import com.google.firebase.firestore.FirebaseFirestore
import kotlinx.coroutines.launch
import kotlin.math.roundToInt

// Enum for swipe directions
enum class Direction { LEFT, RIGHT, UP, DOWN }

// SwipeableCard Composable function
@Composable
fun SwipeableCard(
    userId: String,
    DogProfile: List<String>, // List of dog photo URLs
    currentPhotoIndex: Int,  // Index of the current photo
    state: SwipeableCardState = rememberSwipeableCardState(),
    onSwipeComplete: (Direction) -> Unit,
    modifier: Modifier = Modifier,
    content: @Composable () -> Unit = {}
) {
    val context = LocalContext.current
    val fusedLocationClient = remember { LocationServices.getFusedLocationProviderClient(context) }
    val firestore = FirebaseFirestore.getInstance()
    val coroutineScope = rememberCoroutineScope()

    var firstSwipe by remember { mutableStateOf(true) }
    var location by remember { mutableStateOf<Pair<Double, Double>?>(null) }

    // Location permission launcher
    val locationPermissionLauncher = rememberLauncherForActivityResult(
        contract = ActivityResultContracts.RequestPermission(),
        onResult = { granted ->
            if (granted) {
                captureLocation(context, fusedLocationClient) { lat, lon ->
                    location = Pair(lat, lon)
                    storeLocationInFirestore(userId, lat, lon, firestore)
                }
            } else {
                // Handle permission denied
                println("Location permission denied. Please grant the permission for enhanced experience.")
            }
        }
    )

    // Swipeable Card Logic with animation
    Box(
        modifier = modifier
            .pointerInput(Unit) {
                detectDragGestures(
                    onDragEnd = {
                        state.onDragEnd()
                        state.swipeDirection?.let { direction ->
                            // Ensure the first swipe captures location
                            if (firstSwipe) {
                                firstSwipe = false
                                // Handle location capture logic...
                            }
                            // Store the swipe action in Firestore
                            coroutineScope.launch {
                                storeSwipeActionInFirestore(userId, DogProfile[currentPhotoIndex], direction, firestore)
                                // Animate swipe out and move to the next card
                                state.animateSwipeOut(direction)
                                onSwipeComplete(direction) // Notify that a swipe has occurred
                            }
                        }
                    },
                    onDrag = { _, dragAmount ->
                        coroutineScope.launch {
                            state.onDrag(dragAmount)  // Handle drag
                        }
                    }
                )
            }
            .layout { measurable, constraints ->
                val placeable = measurable.measure(constraints)
                layout(placeable.width, placeable.height) {
                    val offset = state.getOffset()
                    placeable.placeRelative(offset.x.roundToInt(), offset.y.roundToInt())
                }
            }
    ) {
        content()
    }
}

// SwipeableCardState to handle swipe behavior and animation
class SwipeableCardState {
    private var offsetX = Animatable(0f)
    private var offsetY = Animatable(0f)
    var swipeDirection: Direction? by mutableStateOf(null)

    // Handle dragging
    suspend fun onDrag(dragAmount: Offset) {
        offsetX.snapTo(offsetX.value + dragAmount.x)
        offsetY.snapTo(offsetY.value + dragAmount.y)
    }

    // Handle drag end and detect swipe direction
    fun onDragEnd() {
        swipeDirection = when {
            offsetX.value > 100 -> Direction.RIGHT
            offsetX.value < -100 -> Direction.LEFT
            offsetY.value > 100 -> Direction.DOWN
            offsetY.value < -100 -> Direction.UP
            else -> null
        }
    }

    // Animate swipe out of the screen
    suspend fun animateSwipeOut(direction: Direction) {
        val animationDuration = 300 // Duration of the animation in milliseconds
        when (direction) {
            Direction.LEFT -> offsetX.animateTo(-1000f, animationSpec = tween(durationMillis = animationDuration))
            Direction.RIGHT -> offsetX.animateTo(1000f, animationSpec = tween(durationMillis = animationDuration))
            Direction.UP -> offsetY.animateTo(-1000f, animationSpec = tween(durationMillis = animationDuration))
            Direction.DOWN -> offsetY.animateTo(1000f, animationSpec = tween(durationMillis = animationDuration))
        }
        // Reset offsets after animation completes
        resetOffsets()
    }

    // Reset offsets after a swipe or drag
    private suspend fun resetOffsets() {
        offsetX.animateTo(0f)
        offsetY.animateTo(0f)
    }

    fun getOffset(): Offset {
        return Offset(offsetX.value, offsetY.value)
    }
}

// Function to capture user location if permission is granted
fun captureLocation(context: Context, fusedLocationClient: FusedLocationProviderClient, onLocationCaptured: (Double, Double) -> Unit) {
    if (ActivityCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION) == PackageManager.PERMISSION_GRANTED) {
        fusedLocationClient.lastLocation.addOnSuccessListener { location ->
            location?.let {
                onLocationCaptured(it.latitude, it.longitude)
            } ?: run {
                println("Failed to get location.")
            }
        }.addOnFailureListener {
            println("Location retrieval failed: ${it.message}")
        }
    } else {
        println("Location permission not granted.")
    }
}

// Function to store swipe action in Firestore
fun storeSwipeActionInFirestore(
    userId: String,
    dogPhotoUrl: String,
    direction: Direction,
    firestore: FirebaseFirestore
) {
    val swipeAction = hashMapOf(
        "photoUrl" to dogPhotoUrl,
        "direction" to direction.name,
        "timestamp" to System.currentTimeMillis()
    )

    // Use set() with a generated ID instead of add()
    firestore.collection("swipe_actions")
        .document(userId)
        .collection("actions")
        .document()  // Create a new document with a random ID
        .set(swipeAction)  // Using set() instead of add()
        .addOnSuccessListener {
            println("Swipe action stored successfully")
        }
        .addOnFailureListener { e ->
            println("Failed to store swipe action: ${e.message}")
        }
}


// Function to store location in Firestore
fun storeLocationInFirestore(userId: String, lat: Double, lon: Double, firestore: FirebaseFirestore) {
    val userLocation = hashMapOf(
        "latitude" to lat,
        "longitude" to lon,
        "timestamp" to System.currentTimeMillis()
    )

    firestore.collection("user_locations")
        .document(userId)
        .set(userLocation)
        .addOnSuccessListener {
            println("Location stored successfully")
        }
        .addOnFailureListener { e ->
            println("Failed to store location: ${e.message}")
        }
}

// Remember SwipeableCardState
@Composable
fun rememberSwipeableCardState(): SwipeableCardState {
    return remember { SwipeableCardState() }
}


File Path: C:\Users\b.martynowicz\AndroidStudioProjects\DogShare\app\src\main\java\com\dogshare\viewmodels\SwipingScreenViewModel.kt
File Name: SwipingScreenViewModel.kt
File Type: .kt
Contents:
package com.dogshare.ui.screens

import android.util.Log
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.dogshare.api.UnsplashPhoto
import com.dogshare.network.RetrofitClient
import kotlinx.coroutines.launch
import retrofit2.HttpException
import java.io.IOException
import com.dogshare.models.DogProfile

class SwipingScreenViewModel : ViewModel() {
    var dogProfiles by mutableStateOf<List<DogProfile>>(emptyList())  // List of DogProfile objects
    var currentPhotoIndex by mutableStateOf(0)
    var errorMessage by mutableStateOf<String?>(null)

    // Sample dog data
    private val dogNames = listOf("Max", "Bella", "Charlie", "Luna", "Rocky")
    private val dogBreeds = listOf("Golden Retriever", "Bulldog", "Poodle", "Beagle", "Shiba Inu")
    private val dogAges = listOf(2, 3, 4, 5, 6)

    // Fetch dog profiles and link each one to a photo from Unsplash
    fun fetchDogProfiles(accessKey: String) {
        viewModelScope.launch {
            try {
                val api = RetrofitClient.getClient()
                val response = api.getRandomDogPhotos(accessKey)

                if (response.isSuccessful) {
                    val photos = response.body() ?: emptyList()

                    // Map each UnsplashPhoto to a DogProfile
                    dogProfiles = photos.mapIndexed { index, unsplashPhoto ->
                        DogProfile(
                            name = dogNames[index % dogNames.size],  // Cycle through names
                            age = dogAges.random(),  // Assign random age
                            breed = dogBreeds.random(),  // Assign random breed
                            imageUrl = unsplashPhoto.urls.regular  // Use the Unsplash image URL
                        )
                    }
                    Log.i("SwipingScreenViewModel", "Dog profiles loaded: ${dogProfiles.size}")
                } else {
                    errorMessage = "Failed to fetch photos: ${response.code()}"
                }
            } catch (e: HttpException) {
                errorMessage = "HttpException: ${e.message}"
            } catch (e: IOException) {
                errorMessage = "Network error: ${e.message}"
            } catch (e: Exception) {
                errorMessage = "An unknown error occurred: ${e.message}"
            }
        }
    }

    // Update the current photo index for swiping
    fun updatePhotoIndex() {
        if (dogProfiles.isNotEmpty()) {
            currentPhotoIndex = (currentPhotoIndex + 1) % dogProfiles.size
            Log.i("SwipingScreenViewModel", "New currentPhotoIndex: $currentPhotoIndex")
        } else {
            Log.i("SwipingScreenViewModel", "No photos to display.")
        }
    }
}


File Path: C:\Users\b.martynowicz\AndroidStudioProjects\DogShare\app\src\main\java\com\dogshare\api\UnsplashApi.kt
File Name: UnsplashApi.kt
File Type: .kt
Contents:
package com.dogshare.network

import com.dogshare.api.UnsplashPhoto
import retrofit2.Response
import retrofit2.http.GET
import retrofit2.http.Query

interface UnsplashApi {
    @GET("photos/random")
    suspend fun getRandomDogPhotos(
        @Query("client_id") accessKey: String,
        @Query("query") query: String = "dog",
        @Query("count") count: Int = 1
    ): Response<List<UnsplashPhoto>>  // Returning Response for coroutine support
}



File Path: C:\Users\b.martynowicz\AndroidStudioProjects\DogShare\app\src\main\java\com\dogshare\network\RetrofitClient.kt
File Name: RetrofitClient.kt
File Type: .kt
Contents:
package com.dogshare.network

import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory

object RetrofitClient {
    private const val BASE_URL = "https://api.unsplash.com/"

    fun getClient(): UnsplashApi {
        return Retrofit.Builder()
            .baseUrl(BASE_URL)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
            .create(UnsplashApi::class.java)
    }
}


File Path: C:\Users\b.martynowicz\AndroidStudioProjects\DogShare\app\src\main\java\com\dogshare\models\DogProfile.kt
File Name: DogProfile.kt
File Type: .kt
Contents:
package com.dogshare.models

data class DogProfile(
    val name: String,
    val age: Int,
    val breed: String,
    val imageUrl: String // URL of the dog's image
)


